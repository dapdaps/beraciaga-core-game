function x(e){return class extends e{constructor(){super()}}}function S(e){return class extends e{constructor(){super()}_onCreate(){}}}const $={},M={PLUGIN:"plugin",BEHAVIOR:"behavior"},O={WORLD:"world",OBJECT:"object",DOM:"dom"},B=M.BEHAVIOR,C=O.OBJECT,I="skymen_RadialProgress",D=!1;function Y(e){return class extends e{constructor(){super();const t=this._getInitProperties();this.needsRedraw=!0,t&&([this.resolution,this.circular,this.innerRadiusX,this.innerRadiusY,this.outerRadiusX,this.outerRadiusY,this.value,this.maximum,this.inverted]=t),this._setTicking(!0)}_trigger(t){super._trigger(self.C3.Plugins[I].Cnds[t])}_release(){super._release()}_tick(){const t=this.instance.dt,s=this.instance;let n=this.maximum,o=this.value,T=this.inverted,a=this.resolution,l=this.innerRadiusX,d=this.circular?l:this.innerRadiusY,g=this.outerRadiusX,m=this.circular?g:this.outerRadiusY;if(n<=0?(this.lastAngle||(this.lastAngle=s.angle),this.needsRedraw=!0,s.angle+=C3.toRadians(180*t),o=.1,n=1):this.lastAngle&&(s.angle=this.lastAngle,this.lastAngle=null),!this.needsRedraw)return;let R=s.getMeshSize();(R[0]===0||R[0]!==a&&a>2)&&s.createMesh(a,2),l=Math.min(l,g),d=Math.min(d,m),o=Math.min(Math.max(0,o),n);const u=s.angle,p=C3.toDegrees(u),v=(360*o*(T?-1:1)/n+p-p)/(a-1),y=s.width,f=s.height;for(let r=0;r<a;r++){let c=C3.toRadians(p+v*r);s.setMeshPoint(r,0,{x:.5+g*Math.cos(-c+u)/y,y:.5+m*Math.sin(-c+u)/f}),s.setMeshPoint(r,1,{x:.5+l*Math.cos(-c+u)/y,y:.5+d*Math.sin(-c+u)/f})}this.needsRedraw=!1}_saveToJson(){let t=["resolution","circular","innerRadiusX","innerRadiusY","outerRadiusX","outerRadiusY","value","maximum","inverted"],s={};return t.forEach(n=>{s[n]=this[n]}),s}_loadFromJson(t){Object.keys(t).forEach(s=>{this[s]=t[s]})}_getDebuggerProperties(){let t=this._saveToJson(),s=[];return Object.keys(t).forEach(n=>{s.push({name:n[0].toUpperCase()+n.slice(1),value:this[n],onedit:o=>this.setValue(n,o)})}),[{title:"RadialProgress",properties:s}]}setValue(t,s){this[t]!==s&&(this.needsRedraw=!0,this[t]=s)}}}const i={addonType:B,type:C,id:I,hasDomside:D};function P(e){this.setValue("circular",e)}function A(e){this.setValue("innerRadiusX",e)}function X(e){this.setValue("innerRadiusY",e)}function V(e){this.setValue("inverted",e)}function _(e){this.setValue("maximum",e)}function j(e){this.setValue("outerRadiusX",e)}function w(e){this.setValue("outerRadiusY",e)}function E(e){this.setValue("resolution",e)}function K(e){this.setValue("value",e)}const J={},U={SetCircular:P,SetInnerradiusX:A,SetInnerradiusY:X,SetInverted:V,SetMaximum:_,SetOuterradiusX:j,SetOuterradiusY:w,SetResolution:E,SetValue:K},k={},L={};function N(){return this.innerRadiusX}function z(){return this.innerRadiusY}function G(){return this.circular?1:0}function H(){return this.inverted?1:0}function W(){return this.maximum}function F(){return this.outerRadiusX}function q(){return this.outerRadiusY}function Q(){return this.resolution}function Z(){return this.value}const ee={},se={InnerRadiusX:N,InnerRadiusY:z,IsCircular:G,IsInverted:H,Maximum:W,OuterRadiusX:F,OuterRadiusY:q,Resolution:Q,Value:Z},te={object:globalThis.ISDKPluginBase,world:globalThis.ISDKPluginBase,dom:globalThis.ISDKDOMPluginBase},ne={plugin:te[i.type],behavior:globalThis.ISDKBehaviorBase},ie={plugin:globalThis.ISDKObjectTypeBase,behavior:globalThis.ISDKBehaviorTypeBase},oe={object:globalThis.ISDKInstanceBase,world:globalThis.ISDKWorldInstanceBase,dom:globalThis.ISDKDOMInstanceBase},ae={plugin:oe[i.type],behavior:globalThis.ISDKBehaviorInstanceBase},h=Y(class extends ae[i.addonType]{constructor(){super()}});Object.assign(h.prototype,J);Object.assign(h.prototype,k);Object.assign(h.prototype,ee);const b=S(ie[i.addonType]);Object.assign(b.prototype,$);const ue={plugin:"Plugins",behavior:"Behaviors"};globalThis.C3[ue[i.addonType]][i.id]={Acts:U,Cnds:L,Exps:se,Instance:h,Type:b,Plugin:x(ne[i.addonType])};
